package pl.com.labaj.autorecord.extension.arice;

/*-
 * Copyright Â© 2023 Auto Record
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.CodeBlock;
import io.soabase.recordbuilder.core.RecordBuilder;
import org.apiguardian.api.API;
import pl.com.labaj.autorecord.AutoRecord;
import pl.com.labaj.autorecord.context.Context;
import pl.com.labaj.autorecord.context.StaticImports;
import pl.com.labaj.autorecord.extension.CompactConstructorExtension;

import javax.annotation.processing.Generated;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.type.TypeMirror;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import static java.lang.Character.isLowerCase;
import static java.lang.Integer.toUnsignedString;
import static java.lang.Math.abs;
import static java.util.stream.Collectors.joining;
import static javax.lang.model.type.TypeKind.ARRAY;
import static org.apiguardian.api.API.Status.STABLE;
import static pl.com.labaj.autorecord.extension.arice.Names.ARICE_PACKAGE;
import static pl.com.labaj.autorecord.extension.arice.Names.allImmutableNames;
import static pl.com.labaj.autorecord.extension.arice.Names.notPredefinedNames;
import static pl.com.labaj.autorecord.extension.arice.RecordComponent.debugInfo;

/**
 * An implementations of the {@link AutoRecord} {@link CompactConstructorExtension} for customizing a record generation process
 * with support for immutable collections.
 * <p>
 * Components that are collections or maps a being copied to their corresponding immutable types.
 * <p>
 * <b>Note:</b> It is recommended to disable {@link RecordBuilder.Options#useImmutableCollections() useImmutableCollections}
 * and {@link RecordBuilder.Options#useUnmodifiableCollections() useUnmodifiableCollections} features for generated builders.
 */
@API(status = STABLE)
public class ImmutableCollectionsExtension implements CompactConstructorExtension {
    private static final AnnotationSpec GENERATED_WITH_EXTENSION_ANNOTATION = AnnotationSpec.builder(Generated.class)
            .addMember("value", "$S", AutoRecord.class.getName())
            .addMember("comments", "$S", ImmutableCollectionsExtension.class.getName())
            .build();

    private static final String METHODS_CLASS_NAME = ARICE_PACKAGE + ".ARICE";

    private static final ExtensionContext extContext = new ExtensionContext();

    private Set<String> immutableTypeNames;
    private Set<TypeMirror> immutableTypes;
    private Set<String> immutableNames;
    private List<RecordComponent> componentsToProcess;
    private String methodsClassName;

    /**
     * Initializes the extension with the given processing environment and parameters.
     *
     * @param processingEnv The {@link ProcessingEnvironment} providing access to facilities provided by the annotation processing tool.
     * @param parameters    An array of type names that are immutable.
     */
    @Override
    public void init(ProcessingEnvironment processingEnv, String[] parameters) {
        extContext.init(processingEnv);

        immutableTypeNames = notPredefinedNames(parameters);
        immutableNames = allImmutableNames(parameters);
        immutableTypes = extContext.getTypes(immutableNames);
        methodsClassName = methodsClassName();
    }

    /**
     * Determines whether the extension should generate the compact constructor content.
     * <p>
     * It filters out components that:
     * <ul>
     *     <li>are annotated with {@link Mutable} annotation</li>
     *     <li>are primitives</li>
     *     <li>are arrays</li>
     *     <li>has or extends an immutable type</li>
     * </ul>
     * If something has left, the content will be generated.
     *
     * @param isGeneratedByProcessor A flag indicating if the compact constructor is generated by the
     *                               {@link AutoRecord} Processor. If the flag is {@code false},
     *                               it means that compact constructor won't be generated without extensions.
     * @param context                The {@link Context} object containing the annotation processing information.
     * @return {@code true} if the compact constructor should be generated by the extension, {@code false} otherwise.
     */
    @Override
    public boolean shouldGenerateCompactConstructor(boolean isGeneratedByProcessor, Context context) {
        var logger = context.logger();

        var componentBuilder = new RecordComponent.Builder(extContext, immutableTypes, logger);
        var declaredComponents = context.components()
                .stream()
                .filter(recordComponent -> !recordComponent.isAnnotatedWith(Mutable.class))
                .filter(recordComponent -> !recordComponent.type().getKind().isPrimitive())
                .filter(recordComponent -> recordComponent.type().getKind() != ARRAY)
                .toList();
        if (declaredComponents.isEmpty()) {
            return false;
        }

        componentsToProcess = declaredComponents.stream()
                .map(componentBuilder::toExtensionRecordComponent)
                .filter(Objects::nonNull)
                .toList();

        return !componentsToProcess.isEmpty();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CodeBlock suffixCompactConstructorContent(Context context, StaticImports staticImports) {
        var logger = context.logger();

        var structreBuilder = new TypesStructure.Builder(extContext, immutableNames);
        var structure = structreBuilder.buildStructure(logger);

        if (logger.isDebugEnabled()) {
            logger.debug("Components to process:\n" + debugInfo(componentsToProcess));
            logger.note("Types structure:\n" + structure.debugInfo());
        }

        var codeBuilder = CodeBlock.builder();

        var statementGenerator = new StatementGenerator(extContext, structure, methodsClassName, staticImports, logger);

        componentsToProcess.stream()
                .map(statementGenerator::generateStatement)
                .forEach(codeBuilder::addStatement);

        return codeBuilder.build();
    }

    /**
     * Returns, among others, {@link ARICEUtilities} annotation that specifies:
     *
     * @param context       The {@link Context} object containing the annotation processing information.
     * @param staticImports The {@link StaticImports} object containing {@code static import} statements that will be added into the generated record.
     * @return A list of {@link AnnotationSpec} representing annotations that need to be added to the generated record.
     */
    @Override
    public List<AnnotationSpec> annotationsToSupportCompactConstructor(Context context, StaticImports staticImports) {
        var builder = AnnotationSpec.builder(ARICEUtilities.class)
                .addMember("className", "$S", methodsClassName);

        immutableTypeNames.forEach(parameter -> builder.addMember("immutableTypes", "$S", parameter));

        return List.of(GENERATED_WITH_EXTENSION_ANNOTATION, builder.build());
    }

    private String methodsClassName() {
        return METHODS_CLASS_NAME + (immutableTypeNames.isEmpty() ? "" : "_" + stringHashCode(immutableTypeNames));
    }

    private String stringHashCode(Set<String> parameters) {
        var hashCode = parameters.stream()
                .sorted()
                .mapToInt(String::hashCode)
                .reduce(1, (h1, h2) -> 31 * h1 + h2);
        var alphaString = toUnsignedString(abs(hashCode), 26);

        return alphaString.chars()
                .map(i -> isLowerCase(i) ? i - 22 : i + 17)
                .map(i -> 65 + (i + 17) % 26)
                .mapToObj(Character::toString)
                .collect(joining());
    }
}
